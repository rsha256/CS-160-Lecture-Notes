\section{Thursday, April 6th: Browser}
\subsection{Midterm Logistics Review}
This is the last class before our next midterm -- so we will start by reviewing the midterm info again: Midterm \#2 is next Tuesday, April 11th. The same format as midterm number one, which means you don't have to come to the classroom. You can if you want, but the midterm is happening online, will release it at 09:00 A.M. you then have 90 min or 90 min times here DSP exam time within a 24 hour window to take the exam. It is on bcourses as a quiz. We once again have a mix of multiple choice and open answer questions. Most importantly, it is not cumulative. Only material that's not been covered in midterm, one will be on the midterm too. So what is that material? Well, it's lectures 14 through 20, information visualization through number 20, that's today, browsers. And the associated readings, which include the two readings, experiment design and interpreting data. The readings on heuristic evaluation, which will lengthen your heuristic evaluation assignment and then how browsers work. Reading that we assigned. You don't have to submit an answer, but it's a part of it. 

We had some questions about practice midterms. So there are two practice midterms on bcourses under Files, midterms. Those were both examples of second midterms from CS 160. And just the caveat, that material has slightly changed. So we will not ask you about the specifics of Android. You might see some questions in the practice midterms about that because that is no longer the focus of the class. We will also not ask you about midterm one material. So some of the practice midterms, e.g. have questions about color spaces, which we already covered in midterm. Number one. So take it as a guideline of the types of questions we'll ask, the format of the, of the questions, but we will tailor it to the actual lectures we covered this semester. It will once again be open book, open notes, but you shouldn't be talking to other students in the class about the exam, just like midterm number one question, will there be coding? We might ask you some questions that where we show you some code and ask questions about it. Like we might show you HTML, CSS, and JavaScript, but we will not ask you to write code. Yeah, So just to repeat, we might show you code, but we don't ask you to write code to answer the questions. 
\subsection{Implementation}
Today will probably be a shorter lecture partially because it's such a complex topic -- and we should just focus on the the high-level takeaways.

\subsection{Where are we in the course?}
We talked a lot about the design phase and right now we're in the kind of what's the engineering of user interfaces look like. That's what you're programming assignments were about, that's what your implementation of your team project is about. And then in the lectures that we're currently having, we're looking like one layer beyond that because the code you write, What's the system underneath it that works with that code to actually render interactive interfaces to the user. Okay, so here's the quick review of what we talked about last lecture. So native application concepts, right? What did we talk about? We talked about key concepts or widgets or controls. Those are the templates for buttons, date pickers, drop-down menus, radio buttons, etc. And how are they architected? Well, they implement drawing, bounds management and event processing. So they know how to draw themselves. They know how to draw themselves when they get resized. And they can process input events. And some of that processing comes kinda out of the box, right? So a button automatically renders itself as depressed when you press the mouse button over it. And then some of the event processing is basically gives the structure for you to add your own code. So your event handlers so that your own code can execute when that button gets pressed by the user. We talked about that widgets are laid out in a containment hierarchy, right? So we have this tree where all the internal nodes of the tree, our layout nodes and all the leaf nodes are the actual widgets. And the layouts determine how the children of the layout note get arranged on screen. And so parents allocate space for children. And so the layouts allocate space and then tell the widgets, Hey, you have the following bounds. Draw yourself. We've talked about most modern UI toolkits support declarative layout of UIs. So basically, this is usually done in some XML dialect. Right here. What happens in native apps looks kind of like what happens in HTML. You have some XML dialect that specifies at compile time what the structure of the Uighurs. 

However, we also want this to be flexible. And so usually they're also, you can encode also directly manipulate that, that structure to dynamically change the tree at runtime. Then we also talked about events. And events are how we deliver information about user input. Two components and the user interface. And they are the key diagram we talked about was the event dispatch loop, right? Where you have a Q input events go into that queue. The main event loop in your UI toolkit pops these events off one-by-one, figures out what UI components to deliver them too, and then calls the appropriate event handlers on those UI components and delivers the event to them. Then the last thing we talked about was Model-View-Controller. As a way when you do object oriented programming, how do you write the classes that make up a user interface in a way that is extensible and maintainable. And so the key concepts there's you have model classes that just capture all of the information, right? So in a drawing app that would be describe the shapes that are on screen. How big are they? What are their positions? What are their colors and other attributes? Then we have the view classes, which are responsible for rendering a model onto screen. And then we have the controller classes which take input from an input device and then update the model. Then when the model updates, right, the associated views update. And so that was the cycle of how we go from input to output. But in a structured way that is easily extensible and maintainable. So we can add information to our model without having to touch any of the view code. We can add extra views to our application without touching any of the model code. All right? 

Here are a couple of things we already talked about. Event handling, part of the model or controller. So great question. Event handling is not part of the model. It's part of the controller. The controller receives the input, such as I drag on the handle of a shape that's onscreen. The controller may then interpret this as 0. That means I should the user just re-size this shape. So let me find the model class and update its internal width parameter, which in turn then leads to a request to redraw the screen. But event handling happens in the controller. But as a result, we usually then in the controller update the model. Another way to think about this is that if you're assembling your UI from pre-existing widgets and controls, right? Event handling happens in Callback functions on that, on that widget. So that's a control class. Usually you're the internal, how you store information about the application. Those are classes that you create that are not subclasses of widgets and controls, right? Those are model classes. And so event handling happens in the controller, but it often updates a model class as a result. Okay? And then I wanted to go over these slides again. So we talked about wet versus native apps, some pros and cons when you would choose which makes a compatibility on the web is great. You need one code base. We're native apps, it's platform specific, and you might need multiple code bases if you target multiple mobile or laptop operating systems. Software updates and web apps are of course, incident. As soon as you push new code to the server on native apps, that requires we installation of the application. But web apps by themselves cannot run offline. Native apps can. However, these days can all the data usually involves some web service. And so even a native app. What good is Netflix? If you can start up the Netflix app, but you can't access any movies. Not that useful. In terms of functionality we talked about that web apps are often kind of one generation behind what is available natively. And that when a new piece of hardware comes, comes around, like a depth camera or another new type of sensor. That usually, there's usually a native application framework first for using making, taking advantage of that hardware. And then performance-wise, usually web apps have lower performance because there's the additional complexity of the browser and we tackle some of that complexity today. Whereas the native applications you can write. Timing critical components in some low-level compile fast language. And then we also did some mapping of concepts onto each other, right? So how do you declaratively define what the UI structure look likes? It looks like in a native app that some XML layout file in the web app. It's HTML. And we'll talk again how today, how that is not a true XML file, even though it looks like one. Visual appearance rules, we use CSS and Web Apps. And there's usually a notion of styles and themes and Android or other native apps. Css is an especially complex way of implementing visual appearance rules. We'll talk about that a little bit today as well. Application logic is usually written in some native language, right? And UI toolkit in a native application, in a web app gets split across client and server. 

We usually have some way of bridging between the application logic and that declarative UI structure. And how do you define different screens? Well, in a native application that is usually some class, whereas in a web app is just you navigate to a new URL. One last piece of review is what happens when we request a web page from a server. So basically this is the quick review of how do we get all the HTML, CSS, and JavaScript to the browser? And then the rest of today's lecture is, once it's in the browser, what do we do with it? So remember that for web apps, we need a web server. The web server has access to files and then our computer, the computer of the user in this case is the client. It sends a request for a particular resource to a web server. So that happens for web apps over HTTP, Hypertext Transfer Protocol Addresses are encoded as URLs, Uniform Resource Locators. The web server receives the request and then maps that through its internal logic to, okay, so what files do I need to retrieve from my file system? What HTML, CSS, JavaScript should I retrieve? It can of course construct these on the fly as well with computation. It then delivers them back to client and the client. The browser then renders the files as a web app user interface. All right, so then today, the topic is once we've received those types of files like HTTP or HTTPS and the browser, what happens next? And so I'm just going to walk through some of the key concepts in the reading that I've assigned for this. Alright, high-level structure of the browser. The browser's main components are the user interface of the browser as well itself. That is, everything that's not the browser window, right? It is the menu bar. For the browser. It is the URL bar where you enter the URL. It's the backwards button, it's the bookmarks, etc. So everything that's not the requested page itself. Then there's a pair of a browser and a rendering engine. The rendering engine is the key most complex component for displaying the requested content. So if you request it an HTML document, it's responsible for parsing the HTML and the CSS and displaying that on screen. We will mostly talk about that today. The browser engine is basically the layer in-between. Like that, uses what you do in the browser user interface to send commands to the rendering engine. There's a networking component, which is basically the previous three slides, right? How do we actually get the documents from the network for requested URL? And then for all the other documents that might be LinkedIn, it is a JavaScript interpreter, which is usually separate from the rendering engine. So here's a difference between native apps and web apps. And native apps were the Part of interpreting the UI and where you put the callbacks, that's part of the same UI toolkit in the browser, we have separate render, rendering engines of JavaScript interpreter's. The browser also then has a UI backend. We're basically says, Okay, I've received all of this HTML and CSS. When it comes time to draw it on the screen, it's still uses the underlying graphics primitives of the platform it's running on. So just like a UI toolkit in the end will resort to 2D drawing primitives like put text on the screen here, draw a line, draw a rectangle. The browser in the end uses those same calls as well. Then the last component is there's usually a data persistence layer where e.g. all the cookies that you receive gets stored. And HTML5 also has kind of a local storage component where data that's local to the user can be stored in the browser. 

All right, So that's the high-level structure of the different components of a browser. And then most of today we're going to spend on an overview of how rendering and JavaScript works. So, okay, question here was, what about the direct arrow from user-interface to UI backend? When does this happen? So think about the browser Chrome, like thinking about the address bar and the back button in the browser, that has to get drawn on screen as well, right? And so there, the user interface component of the browser uses the UI backend to use those low-level drawing primitives to put the buttons and menus on screen. Thanks for the question. All right, let's keep going here. Okay. So high-level overview, what the rendering engine does, it is it gets the HTML and the CSS. It has to parse them to understand their structure. So HTML goes kind of video content tree, CSS goes into a style tree, and then that information has to be fused together to determine for a given element what style should we render it in? That's called constructing the render tree. And then the render tree has all of the components that should be displayed on screen and now has their visual styles. And then there's a layout pass where you determine, well, where, how big is it, where should it go on screen? And then once you've done a passive or that, then painting happens, which is using the UI backend. You just draw stuff into the viewport. On the JavaScript engine, we get the JavaScript, we parse that, we compile it and execute it. Alright, so let's delve into that. Let's start with the rendering engine. Okay? So the rendering engine, that's the piece of code that's responsible for displaying the received content in the browser window. Most of the code and rendering engines focus on HTML CSS, because that is what the width is built on. But rendering engines can also have plug-ins and extensions to handle other formats, right? E.g. most browsers can directly render a PDF. So there are some extension for rendering PDF structured data. But most of the core of the rendering engine is for HTML and CSS. Now, different browsers use different engines. And one thing that's interesting here is that basically what we use today is all, all goes back to open source software. So for those of you who are using Linux, you might have at some point used browser called Katie conqueror. And that had a rendering engine called K. Html was particularly standards compliant. And then pretty much everything else that the commercial companies use these days somehow goes back to that open source code base. So Apple Safari browser, the rendering engine is called webkit and web kit at some point was forked from K HTML. Google Chrome uses a rendering engine called blink. Blink at some point was forked from webkit, or more precisely, it's web core component. So also goes back to HTML. Interesting detail is if you use Chrome on iOS, on an iPhone, then it actually Doesn't use blink, it uses webkit because that's an App Store policy in iOS. So their Chrome actually uses different rendering engines based on the platform that you use it on. Microsoft Edge, microsoft used to use it, right, its own rendering engine. They've now abandoned that and they're also using blink. And then the only other kind of independent project that has significant traction is Mozilla Firefox. They use gecko and of course, Firefox also open-source project. Let's look in one level more detail how this rendering engine flow works. So we start by receiving HTML and style sheets. Then we parse the HTML and the output of that is a DOM tree. 

So the Document Object Model tree, style sheets, we parsed and we get a tree of style rules. And then there's this merging process where we attach style rules to particular elements in the DOM. And that yields a render tree. The render tree has to go through a layout phase and then goes to painting to draw. Once layout determines the sizes and positions of elements, we painted onto screen, onto the display. 

\subsection{Parsers}
Alright, so let's talk for a minute here about parsers, how that works. So let's maybe get a show of hands. 
\begin{shaded}
Who here has taken CS 164 or a version of it -- a PL (Programming Languages) course.
\end{shaded}
Today we are gonna to see the high level intuition of how basically HTML and CSS are custom domain specific languages that for you to program a document structure and visual attributes. And here's like one-six-four in a nutshell of how you parse and then interpret a custom domain specific language. If you want to know more about it than I highly recommend you take that course probably with Sarah Jason's or Zen. Super important can a basic topic in computer science. Okay? So we just received a document which is basically a bunch of characters and we want to understand the meaning of that document. So a common pattern, Which mode, which we use to interpret most programming languages and most domain-specific languages is. We go through a two-step process of first flexing and then parsing. And so lexical analysis, we usually, we turn the document that we've received into a stream of tokens. And so a token could be, this is a string, this is a number. This is a special character. Usually we define what a token is, two regular expressions. So we passed all the characters we received in a document through a set of regular expressions. See which ones match, and then emit a bunch of tokens. In the next step, we then consume the stream of tokens and try to build a hierarchical representation. So a parse tree out of this tokens. The way we use that we do that is usually we define a context-free grammar that defines the structure of legal statements and expressions in our language. The usual tools that you, there's lots of tooling around that. And so traditionally in Unix and used to be lex and yacc, those tools are now called flex and bison. So one is a lexer, the other one is a parser. There's also, by Professor at the University of San Francisco, wrote a tool that has a great community called antler, which is a parser generator. And so what you usually do is you provide a definition of for Alexa, you provide a definition for a parser. And then a parser generator will generate the code that can then process a document and give you a parse tree back. So let's look at a really simple example. Let's look at here's a snippet of valid XML. Tag, attribute equals value, some text in between and then end tag. How do we create a parse tree for that example? So here's what a simplified XML lexer and Parser would look like. That could deal with such input. So first you would define a lexer. So here what you see is basically on the left-hand side, you see a definition like I define a token like tags start open. That's the name of my token. And what is it? Well, it's the string Open tag. Tag closes the string close tag. Then we have something like a digit. And now this is a regular expression. It's a digit 0-9. Letter is between lowercase a to lowercase z or uppercase a through uppercase Z. Whitespace is a tab. New line or a space. I'm an identifier is a letter or some sequence of letters and digits, right? So I define a bunch of regular expressions and give them names. And once I have these in place, right, I can just scan like start scanning the text I'm given and say, Oh, here's a tag, start open. So I admit that I emit that token, does. Next thing that matches what I defined as generic ID is another generic idea. Here's a tag close. Here's something that's not within a tag in in XML that's called PC data. Parsed character data, sorry. And so we just turn this document we received into a set of tokens. And then the next thing you do is once I have that set of tokens, I define a grammar. Where the grammar can have I defined rules that match some sequence of tokens and other rules, right? So e.g. two, start, the start tag in XML. Is we have that. Sorry, let me try to get to. This is just this character, right? Generic ID, that is the name of the tag. Then we close the tag, that is this. And then we have zero or more attributes that can be in there. What's an attribute? Well, this is a different rule. An attribute has some name, equals, that's the equal sign. And then it has a value. And then by the end, so we define these rules. And then we say an element in XML has a start tag. Inside of it. It can either have other elements or just some texts. Zero more of those. And then we have an end tag. So now we've defined a grammar over these tokens. And what I can now then do is construct a tree based on matching grammar rules, right? So we have a top-end element that is this whole string. Within that. We have start tag that goes from here to here. We have some text inside of it that is from here to here. We have N tag that goes from here to here. And then within the star tag, this matches the name of the tag itself. And then we have an attribute node, which has an ID, which is this part, and a value which is this part. Of course, inside of this tag, we might have other tags in here, right? And then the tree would just get more complex. So through this two-state stage process, we started off with just some character data that we received in the browser. And then we now turned it into a scree representation of that domain specific language. Okay? So unfortunately that is, it would be great if we, we're done here. That's the basic approach of how you parse CSS and JavaScript. For both CSS and JavaScript. We can define a set of lexer rules. We can define a context-free grammar and we can parse it in that form. Unfortunately, that does not work for HTML. And other question is, why not? Html looks like XML, right? Shouldn't just be an XML dialect. And unfortunately, HTML rakes some of the rules of XML in a couple of ways. So examples of valid HTML that are not valid XML, an image tag, the image source URL here. Why is this not valid XML? Because it doesn't add any point have a closing tag. Same thing for a new line, a line break. What's missing? We don't have a closing tag. Another example, you can write input type equals checkbox. But based on the rules that we defined, every attribute, the value has to be in quotes. So there's a bunch of ways in which you can write HTML that's valid HTML. But it's not valid XML. As a result, you cannot use standard context-free grammar based parser. It can deal with these edge cases. The other big reason is lots of people write HTML by hand and they make a bunch of mistakes. And browsers want to be able to render HTML even in the presence of errors. They don't just want to throw up an error set malformed HTML. I'm not going to show you anything. Let's talk about that for a moment. Okay, here's some HTML. Look at it and tell me in the chat what is wrong with the following snippet of HTML? There are multiple errors in here. Look at it, think about it, and then tell me in the chat what you think is wrong. Alright? Says nested tags. In particular, what's, what's wrong with the nesting? Yeah, okay, farm Rahul and rationality all have the right idea, right? As these two go together. And these two go together. This breaks the nesting relationship. The P has to be closed within the div to be valid, right? But people do this, people write stuff like this. So the p, This would need to move down here. Okay. Anything else you see that is wrong, right? My tag that doesn't exist, that is not a valid HTML tag, not part of the HTML spec. So what should a browser do when it receives such HTML? To just throw basically a compile-time error was like, I'm not going to render this document. In general, browsers say no, that's not what we should do. We should try to fix the errors that are here and just do a best effort at rendering. 

Okay? So what happens is HTML parsers as implemented in browsers, they still have a tokenization and a tree construction phase. But we don't just use the standard lexer and a parser. There's like more complicated code that runs that e.g. checks for all kinds of custom error conditions and then corrects the HTML's ago, we think maybe you meant this. So we're not gonna go into the details of how that happens, but you can look it up into HTML spec on this link, which suggests the structure of such a parser. So high-level structure of the parts are still the same, but at a low-level would actually happens under the hood is way more complex. Okay. Now we get to parceling CSS. Css is much more well-behaved. Css. The language definition for CSS is really clean and can be parsed with the standard lexer and Parser. So we take something like the character stream up here and then we produce a tree of CSS. Alright, so we've passed our HTML with a much more complex parser, constructed a DOM. We parsed CSS and we now have our CSS tree. What do we need to do next? Well, what we want to end up with is a render tree. So a render tree has the visual elements in the order they will be displayed on the page. And each node or render knows how to layout itself and its children. So that's a render tree, kind of like containment hierarchy, right? Each node knows how to draw itself. The renderers and the render tree kind of correspond to DOM elements, but the relationship is not one-to-one. E.g. the head element in HTML, anything that's in the head doesn't get rendered in the viewport. Elements with a CSS style of display, none are not rendered. On the other hand, we have complex elements like a drop-down on a form that might need multiple renderers. So we end up with some tree here that has a relationship to the DOM, but it's not necessarily a one-to-one relationship. The next important thing we need to do is we need to match which visual styles that are defined in CSS and HTML we should attach to each of the nodes in our render tree. Visual styles. There's a bunch of different ways in which you can define visual styles. So you can author CSS rules. Css document. You can also in the HTML L itself, have CSS style attributes. In addition, HTML has visual attributes, like setting the background color on a paragraph, which is not CSS syntax, but also defines a visual style. We have three different sources of where style rules come from. And then for the CSS rules, they actually can be many different style sheets that a single UI loads it. So in particular, there are not just the page style sheets. These are the ones that as an application developer, you define. But the browser also has a default style sheets. So if there are no CSS rules, what font you use, how big should it be? That's a browser default style sheet. And then each user profile in the browser can also have style sheets where you just set your preferences. I want everything rendered at 150 per cent. I prefer the following background. And then each style sheet can have many rules. Now there's a question of, well, how do we look up which rule to apply when this is where the cascade order comes in, which is the C in CSS, right there. Not just style sheets, but they are cascading style sheets. So what does the cascade order mean? You can look it up in the specification for CSS. It basically says there is an important, there's an order of importance. So in ascending order, the least important rules are user agent that those are the browser rules. Browser user normal declarations, these are the user's preferences. Author declarations are the author of the web app, right? So this is web app. And then there is a level of importance. So if you have a exclamation mark important rule, then it kinda supersedes others. So you first look up, is there a user important declaration? If not, let's go through the Web App declarations. Then let's go through the user's normal preferences and then the browser preferences. And basically the higher, the higher ones take precedence over the low ones. So that's what we mean by the cascade order in cascading style sheets. And then the other part that happens is we have a tree, right? We have a tree of HTML. Elements are dumb. Next thing that happens, let's say we're at this element down here. What do we do? We look up the cascade. So these were the rules I just talked about. Can we find a value for background or text color? If so, we use it. If not, we go up the tree and we check, did this node define background, color and font? If so, we use it from here. If not, we go yet further up the tree. So the upshot of all of that is actually matching styles two nodes is not a trivial process at all. You need to consider multiple sources and different preferences, which makes the whole thing kind of more complex than if you just have a style parameter in a native UI. Alright? But at the end of this render tree construction, we basically have everything that gets rendered on onscreen and we have the right CSS style attributes attached to each of the nodes. The final thing we have to do is now we have the styles, but we don't yet have the sizes. And so the final path that happens is a layout stage, where we basically go from Herron down the tree to children. We determine the width of an element that could come e.g. from a CSS style rule. Then we recurse on the children, call land on the children if needed. Maybe calculate their height and then from all of those heights, we calculate our own heights. So it's kind of a panel down, bubble up algorithm where based on available width, the calculate heights, and set those for the whole tree. And then we have basically the bounds for each of the boxes. And once we have those box bounds, we can just call paint. And then paint. It now has all of the absolute coordinates that it should use and abuse this drawing primitives like put texts at x location x, y with the following color and the following font. But this is now this uses the same underlying primitives as UI toolkit in its draw method. So we have access to 2D drawing primitives, lines, boxes, texts, colors. So one way to look at it is that this whole rendering engine, I'm in the browser does the work of the UI toolkit. It just does it in a kind of a more complex way because we have to deal with the vagaries of HTML. We have to be very error permissive. Whereas a UI toolkit, if you give it a malformed XML, let's say error can't deal with this. And on the other hand, we have this really flexible Cascading Style System, which is also more complex than style definitions in native UI Toolkit. Okay, then just briefly, so we just covered what is happening up here. And then just briefly wanted to touch on what's happening down here, but not in a lot of detail. Which is we also get a bunch of JavaScript from the web server, right? So what do we do with that? So the first part is we parse it. So a JavaScript parser. This here is kind of what we just talked about in the parsing S aspects. So we'll have a lexer and a parser. And then in the end, we end up with an abstract syntax tree, which is a tree presentation of the code we just received. Now, JavaScript is an interpreted language. But interpreting all of the JavaScript that we received would be too slow. That's what web browsers did in the very early days of the web. This is not what we do any anymore. Instead, we compile JavaScript using a just-in-time or a JIT compiler into machine code. And then. Execute that to speed it up. And in fact, just this box of how do we make JavaScript faster has been endless engineering on that part. And what's actually happening in browsers these days under the hood is not just we don't interpret, but it's more complex than that. So here e.g. is an example of what the V8 JavaScript engine does in Chrome. And it basically has two pathways. He has a compiler that this is the fast pass. So we get our source code, we compile it into bytecode. We have a bytecode interpreter and executed. And while this execution is happening, if we have spare cycles, will say, Well, we tried to go through this path as fast as possible. But as a result, this is not highly optimized. It's way better than interpreting it, but it's still kinda slow. So that's in the background. Launch another path. And try to optimize this bytecode that we received with an optimizing compiler. And once that is ready, replace this binary with an optimized binary and start executing that. Kinda way more complex. Again, then what's happening in a UI toolkit, right? We're, we're just, we're compiling the code that you gave us and we're running it at runtime. Based on the design decisions that were made early on is that we attach this JavaScript. We're just kind of by accident, this interpreted language took over. And now we have to deal with the fact that we have this kind of not very optimal language. But we really want fast application performance. And so we need way more machinery on the backend to get something like native performance out of it. Okay, so there are tons of details like if you want to become a browser engineer. So Irina asks, I'm curious why not just do the optimization first, then render the optimized code. Because this path down here is fast to compute. Slow to execute. This path up here is slow to compute and then passed to execute. 

So the desire is that like your web browser is loading and this JavaScript code, we want to start executing it as quickly as possible, right? So from the time, from the time that we receive this document of JavaScript, we want to start executing that code right away. So you want to do the fast just-in-time compilation and start executing it. Then in the background, say, well, yeah, but now this execution, this bytecode we got, we can probably do better. But it'll take us a couple of hundred milliseconds to maybe optimize it. So we optimize it behind the scenes and then replace it. And yes, either could be faster as the final result. You don't know, right? Because you're just getting this JavaScript code stream then in synchronously in real time. Great question. Okay. That brings us to That's kind of the level at which I want. However this, so if you want to become a browser engineer, that's like being a highly skilled software engineer in all the vagaries of implementing either the rendering engine or the JavaScript engine. I think those are very highly sought after skills, but only a couple of people focused on that. But hopefully, even as a application developer, even if you're never touching the source code of the rendering engine with the JavaScript engine, it's good to have the conceptual overview of what happens underneath the hood and an understanding of it.

